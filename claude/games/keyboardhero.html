<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KeyboardHero</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            border-left: 2px solid #333;
            border-right: 2px solid #333;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            margin-top: 20px;
        }

        #progress-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background: #111;
            z-index: 5;
        }
        
        #progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            transition: width 0.2s linear;
            box-shadow: 0 0 10px #00ffff;
        }

        /* HOME BUTTON */
        #home-btn {
            pointer-events: auto;
            background: transparent;
            border: 1px solid #555;
            color: #888;
            padding: 5px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer;
            z-index: 20;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        #home-btn:hover {
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            background: rgba(0, 255, 255, 0.1);
        }

        .score-box {
            text-align: right;
        }

        .health-container {
            width: 300px;
            height: 20px;
            background: #222;
            border: 2px solid #555;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        #health-bar {
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.1s linear;
        }

        #combo-display {
            font-size: 3rem;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff;
            font-weight: 900;
            opacity: 0;
            transition: opacity 0.2s;
            text-align: center;
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Menu Overlay */
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 4rem;
            margin: 0 0 20px 0;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .diff-btn {
            background: transparent;
            border: 1px solid #555;
            color: #888;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
        }

        .diff-btn.active {
            border-color: #00ffff;
            color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        /* Options Row (Mute & Practice) */
        .options-row {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }

        .option-label {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            color: #00ffff;
            cursor: pointer;
            text-transform: uppercase;
        }

        .option-label input {
            transform: scale(1.5);
            margin-right: 10px;
            accent-color: #00ffff;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            max-width: 800px;
        }

        button {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            position: relative;
        }

        button:hover {
            background: #00ffff;
            color: black;
            box-shadow: 0 0 20px #00ffff;
        }

        /* Completed Level Style */
        button.completed {
            border-color: #00ff00;
            color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        
        button.completed::after {
            content: "âœ“ CLEARED";
            position: absolute;
            top: -10px;
            right: -10px;
            background: #00ff00;
            color: black;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        .stats-panel {
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #ff00ff;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            display: none;
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.2);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 1.2rem;
            border-bottom: 1px solid #333;
        }

        .grade {
            font-size: 6rem;
            font-weight: 900;
            margin: 20px 0;
            color: gold;
            text-shadow: 0 0 30px gold;
        }

        #start-instruction {
            margin-top: 20px;
            color: #888;
            font-size: 0.9rem;
        }

        #practice-hud {
            display: none;
            position: absolute;
            top: 130px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            z-index: 5;
        }

        input[type="range"] {
            width: 200px;
            accent-color: #00ffff;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="progress-container">
            <div id="progress-fill"></div>
        </div>

        <button id="home-btn" onclick="quitToMenu()">HOME</button>

        <div class="hud-top">
            <div>
                <div style="font-size: 1.5rem">MULTIPLIER</div>
                <div id="multiplier-display" style="font-size: 3rem; color: #00ffff">x1</div>
            </div>
            <div class="score-box">
                <div style="font-size: 1.5rem">SCORE</div>
                <div id="score-display" style="font-size: 3rem">000000</div>
            </div>
        </div>
        <div id="combo-display">COMBO 10!</div>
        <div style="align-self: center">
            <div style="text-align: center; margin-bottom: 5px;">SYSTEM INTEGRITY</div>
            <div class="health-container">
                <div id="health-bar"></div>
            </div>
        </div>
        
        <!-- Practice HUD -->
        <div id="practice-hud">
            <div style="color: #00ffff; margin-bottom: 5px; font-size: 0.8rem;">TEMPORAL DILATION (SPEED)</div>
            <input type="range" id="speed-slider" min="0.1" max="1.0" step="0.1" value="1.0" oninput="updateSpeed(this.value)">
            <div id="speed-value" style="font-weight: bold; margin-top: 5px;">100%</div>
        </div>
    </div>

    <!-- Menus -->
    <div id="menu-overlay">
        <!-- Main Menu -->
        <div id="main-menu">
            <h1>KEYBOARD HERO</h1>
            
            <p style="margin-bottom: 10px; font-family: 'Roboto Mono'">SELECT DIFFICULTY</p>
            <div class="difficulty-selector">
                <button class="diff-btn" id="btn-easy" onclick="setDifficulty('EASY')">EASY</button>
                <button class="diff-btn active" id="btn-medium" onclick="setDifficulty('MEDIUM')">MEDIUM</button>
                <button class="diff-btn" id="btn-expert" onclick="setDifficulty('EXPERT')">EXPERT</button>
            </div>

            <div class="options-row">
                <label class="option-label">
                    <input type="checkbox" id="practice-mode-toggle">
                    Practice Mode (No Fail)
                </label>
                <label class="option-label">
                    <input type="checkbox" id="mute-toggle" onchange="toggleMute(this)">
                    Mute Audio
                </label>
            </div>

            <p style="margin-bottom: 10px; margin-top: 10px; font-family: 'Roboto Mono'">SELECT PROTOCOL LEVEL</p>
            <div class="level-grid" id="level-buttons">
                <!-- Generated by JS -->
            </div>
            <div id="start-instruction">Audio required. Click a level to initialize.</div>
        </div>

        <!-- Post Game Report -->
        <div id="post-game" class="stats-panel">
            <h2 id="report-title">MISSION COMPLETE</h2>
            <div class="grade" id="report-grade">S</div>
            <div style="width: 400px; margin: 0 auto;">
                <div class="stat-row"><span>Final Score</span><span id="report-score">0</span></div>
                <div class="stat-row"><span>Accuracy</span><span id="report-accuracy">0%</span></div>
                <div class="stat-row"><span>Max Combo</span><span id="report-combo">0</span></div>
                <br>
                <div class="stat-row" style="color: #00ffff"><span>PERFECT</span><span id="report-perfect">0</span></div>
                <div class="stat-row" style="color: #00ff00"><span>GREAT</span><span id="report-great">0</span></div>
                <div class="stat-row" style="color: #ffff00"><span>GOOD</span><span id="report-good">0</span></div>
                <div class="stat-row" style="color: #ff0000"><span>MISS</span><span id="report-miss">0</span></div>
            </div>
            <br>
            <button onclick="returnToMenu()">RETURN TO HUB</button>
        </div>
    </div>
</div>

<script>
/**
 * KEYBOARD HERO - DEVELOPER BLUEPRINT IMPLEMENTATION
 */

// --- CONSTANTS & CONFIG ---
const CANVAS_WIDTH = 1000; 
const CANVAS_HEIGHT = 900; 
const SPAWN_Y = -50;
const KEYBOARD_Y = 600; 
const HIT_WINDOW_PERFECT = 40; // ms
const HIT_WINDOW_GREAT = 80;   // ms
const HIT_WINDOW_GOOD = 120;   // ms
const SONG_DURATION = 60; // seconds - CHANGE THIS to adjust level length for testing

// Difficulty Settings
const DIFFICULTY_CONFIG = {
    'EASY': { scrollSpeed: 250, densityMod: 0.6 },
    'MEDIUM': { scrollSpeed: 450, densityMod: 1.0 },
    'EXPERT': { scrollSpeed: 650, densityMod: 1.6 }
};

// Level Definitions (Keys allowed per level)
const LEVEL_DATA = [
    { id: 1, name: "Home Row", keys: "asdfghjkl;'" },
    { id: 2, name: "Top Row", keys: "qwertyuiop[]" },
    { id: 3, name: "Bottom Row", keys: "zxcvbnm,./" },
    { id: 4, name: "Number Row", keys: "1234567890-=" },
    { id: 5, name: "Top + Home", keys: "qwertyuiop[]asdfghjkl;'" },
    { id: 6, name: "Basic Alpha", keys: "qwertyuiop[]asdfghjkl;'zxcvbnm,./" },
    { id: 7, name: "Alphanumeric", keys: "qwertyuiop[]asdfghjkl;'zxcvbnm,./1234567890-=" },
    { id: 8, name: "Shifted Bottom", keys: "qwertyuiop[]asdfghjkl;'zxcvbnm,./1234567890-=<>?:{}" },
    { id: 9, name: "Symbols", keys: "qwertyuiop[]asdfghjkl;'zxcvbnm,./1234567890-=<>?:{}!@#$%^&*()_+" },
    { id: 10, name: "God Mode", keys: "qwertyuiop[]asdfghjkl;'zxcvbnm,./1234567890-=<>?:{}!@#$%^&*()_+ABCDEFGHIJKLMNOPQRSTUVWXYZ" }
];

// --- VISUAL KEYBOARD LAYOUT MAPPING ---
const KEYBOARD_LAYOUT = [
    "`1234567890-=",
    "qwertyuiop[]\\",
    "asdfghjkl;'",
    "zxcvbnm,./"
];

const SHIFT_MAP = {
    '~':'`', '!':'1', '@':'2', '#':'3', '$':'4', '%':'5', '^':'6', '&':'7', '*':'8', '(':'9', ')':'0', '_':'-', '+':'+',
    '{':'[', '}':']', '|':'\\', ':':';', '"':"'", '<':',', '>':'.', '?':'/'
};

const KEY_COORDS = {}; 
const KEY_SIZE = 55;
const KEY_GAP = 5;

// --- AUDIO SYSTEM (Web Audio API) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let noiseBuffer = null;
let bgmInterval = null;
let nextNoteTime = 0;
let beatCount = 0;
let isMuted = false;

// Dynamic Music State
let currentTempo = 120;
let currentBassFreq = 55;
let currentHihatRate = 1; // 1 = 8th notes, 2 = 16th notes

// Initialize White Noise Buffer for "Typewriter" effect
function createNoiseBuffer() {
    if (noiseBuffer) return;
    const bufferSize = audioCtx.sampleRate * 0.1; // 0.1 seconds
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }
    noiseBuffer = buffer;
}

function toggleMute(checkbox) {
    isMuted = checkbox.checked;
    if (isMuted) {
        if (audioCtx.state === 'running') audioCtx.suspend();
    } else {
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }
}

function playSound(type) {
    if (isMuted) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    createNoiseBuffer(); 

    const now = audioCtx.currentTime;
    const gain = audioCtx.createGain();
    gain.connect(audioCtx.destination);

    if (type === 'type') {
        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;
        const noiseFilter = audioCtx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 1000;
        noise.connect(noiseFilter);
        noiseFilter.connect(gain);
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        noise.start(now);
        noise.stop(now + 0.05);
        
    } else if (type === 'error') {
        const osc = audioCtx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
        osc.connect(gain);
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        
    } else if (type === 'miss') {
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(80, now + 0.4);
        osc.connect(gain);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0.001, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
    }
}

// --- BGM ENGINE (Procedural Techno) ---
function playDrum(time, type) {
    if (isMuted) return;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    if (type === 'kick') {
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
        gain.gain.setValueAtTime(0.7, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
        osc.start(time);
        osc.stop(time + 0.5);
    } else if (type === 'hihat') {
        createNoiseBuffer();
        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 5000;
        noise.connect(filter);
        filter.connect(gain);
        gain.gain.setValueAtTime(0.3, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
        noise.start(time);
        noise.stop(time + 0.05);
    } else if (type === 'bass') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(currentBassFreq, time); 
        gain.gain.setValueAtTime(0.2, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
        osc.start(time);
        osc.stop(time + 0.2);
    }
}

function scheduler() {
    const secondsPerBeat = 60.0 / currentTempo;
    const lookahead = 0.1; 

    while (nextNoteTime < audioCtx.currentTime + lookahead) {
        // 4/4 Beat Logic
        // Kick on 1, 2, 3, 4
        playDrum(nextNoteTime, 'kick');
        
        // Hihat logic (8th or 16th notes based on intensity)
        // 8th notes
        playDrum(nextNoteTime + secondsPerBeat/2, 'hihat');
        
        // If high intensity, add 16th notes
        if (currentHihatRate === 2) {
             playDrum(nextNoteTime + secondsPerBeat/4, 'hihat');
             playDrum(nextNoteTime + (secondsPerBeat * 0.75), 'hihat');
        }
        
        // Bassline on offbeats
        playDrum(nextNoteTime + secondsPerBeat/2, 'bass');

        nextNoteTime += secondsPerBeat;
        beatCount++;
    }
    bgmInterval = requestAnimationFrame(scheduler);
}

function startMusic(levelId) {
    if (audioCtx.state === 'suspended' && !isMuted) audioCtx.resume();
    
    // Procedural Parameters based on Level
    // Tempo ranges from 110 (Lvl 1) to 170 (Lvl 10)
    currentTempo = 110 + (levelId * 6);
    
    // Bass Pitch: Pentatonic-ish scale mapping
    const baseFreqs = [55, 65.41, 73.42, 82.41, 98.00]; // A, C, D, E, G
    currentBassFreq = baseFreqs[(levelId - 1) % baseFreqs.length];
    
    // Rhythm Complexity
    currentHihatRate = (levelId > 5) ? 2 : 1;

    nextNoteTime = audioCtx.currentTime + 0.1;
    beatCount = 0;
    scheduler();
}

function stopMusic() {
    if (bgmInterval) cancelAnimationFrame(bgmInterval);
}

// --- GAME STATE ---
let gameState = 'MENU'; 
let isPracticeMode = false;
let currentDifficulty = 'MEDIUM'; // Default
let currentScrollSpeed = 450;
let timeScale = 1.0;
let currentLevelData = null;
let notes = []; 
let particles = [];
let songChart = []; 
let gameTime = 0; 
let lastFrameTime = 0;
let nextNoteIndex = 0;
let pressedKeys = {}; 
let completedLevels = new Set(); // Track cleared levels

// Stats
let score = 0;
let health = 50; 
let combo = 0;
let maxCombo = 0;
let multiplier = 1;
let stats = { perfect:0, great:0, good:0, miss:0 };

// Canvas Setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

// --- INIT VIRTUAL KEYBOARD ---
function initKeyboardCoords() {
    const totalW = 14 * (KEY_SIZE + KEY_GAP); 
    const startX = (CANVAS_WIDTH - totalW) / 2;
    
    KEYBOARD_LAYOUT.forEach((rowStr, rIndex) => {
        let rowOffset = rIndex * 20; 
        for(let i=0; i<rowStr.length; i++) {
            const char = rowStr[i];
            const x = startX + rowOffset + (i * (KEY_SIZE + KEY_GAP));
            const y = KEYBOARD_Y + (rIndex * (KEY_SIZE + KEY_GAP));
            KEY_COORDS[char] = { x, y, w: KEY_SIZE, h: KEY_SIZE, baseChar: char };
        }
    });
}

function getTargetCoord(char) {
    const lower = char.toLowerCase();
    if (KEY_COORDS[lower]) return KEY_COORDS[lower];
    if (SHIFT_MAP[char]) {
        const base = SHIFT_MAP[char];
        if (KEY_COORDS[base]) return KEY_COORDS[base];
    }
    if (KEY_COORDS[char.toLowerCase()]) return KEY_COORDS[char.toLowerCase()];
    return { x: CANVAS_WIDTH/2, y: KEYBOARD_Y, w: KEY_SIZE };
}

// --- CORE CLASSES ---

class Note {
    constructor(char, time) {
        this.char = char;
        this.targetTime = time;
        this.hit = false;
        this.processed = false; 
        
        const coord = getTargetCoord(char);
        this.x = coord.x + coord.w / 2; 
        this.targetY = coord.y + coord.h / 2; 
        
        const dist = this.targetY - SPAWN_Y;
        const timeToTravel = dist / currentScrollSpeed;
        this.spawnTime = this.targetTime - timeToTravel;
    }

    get y() {
        return this.targetY - (this.targetTime - gameTime) * currentScrollSpeed;
    }

    draw(ctx) {
        if (this.hit) return;

        const y = this.y;
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00ffff';
        ctx.fillStyle = '#000';
        ctx.strokeStyle = '#00ffff';
        
        const size = 45;
        ctx.beginPath();
        ctx.roundRect(this.x - size/2, y - size/2, size, size, 6);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 0;
        ctx.font = 'bold 20px "Roboto Mono"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.char, this.x, y);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0;
        this.color = color;
    }
    
    update(dt) {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= dt * 2; 
    }
    
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class FloatingText {
    constructor(text, x, y, color) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.life = 1.0;
        this.color = color;
    }
    
    update(dt) {
        this.y -= 50 * dt; 
        this.life -= dt * 1.5;
    }
    
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.font = 'bold 20px "Orbitron"';
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

// --- GAME LOGIC ---

function setDifficulty(diff) {
    currentDifficulty = diff;
    
    // Update UI buttons
    document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`btn-${diff.toLowerCase()}`).classList.add('active');
}

function quitToMenu() {
    gameState = 'MENU';
    stopMusic();
    document.getElementById('menu-overlay').style.display = 'flex';
    document.getElementById('main-menu').style.display = 'block';
    document.getElementById('post-game').style.display = 'none';
    initMenu();
}

function generateSong(levelId) {
    const level = LEVEL_DATA.find(l => l.id === levelId);
    const availableKeys = level.keys.split('');
    const chart = [];
    
    const config = DIFFICULTY_CONFIG[currentDifficulty];
    
    const songLength = SONG_DURATION; 
    // Base BPS modified by difficulty density
    const bps = (1.0 + (levelId * 0.2)) * config.densityMod; 
    
    let time = 2.0; 
    
    while(time < songLength) {
        const key = availableKeys[Math.floor(Math.random() * availableKeys.length)];
        
        chart.push({
            char: key,
            time: time
        });
        
        const gap = (1 / bps); 
        const mod = Math.random();
        if(mod > 0.8) time += gap * 2;
        else if(mod > 0.6) time += gap / 2;
        else time += gap;
    }
    
    return chart;
}

function initGame(levelId) {
    gameState = 'PLAYING';
    
    const toggle = document.getElementById('practice-mode-toggle');
    isPracticeMode = toggle.checked;
    timeScale = isPracticeMode ? parseFloat(document.getElementById('speed-slider').value) : 1.0;

    // Apply Difficulty Settings
    const config = DIFFICULTY_CONFIG[currentDifficulty];
    currentScrollSpeed = config.scrollSpeed;

    document.getElementById('practice-hud').style.display = isPracticeMode ? 'block' : 'none';
    if(isPracticeMode) updateSpeed(timeScale);

    currentLevelData = LEVEL_DATA.find(l => l.id === levelId);
    songChart = generateSong(levelId);
    
    notes = [];
    particles = [];
    gameTime = 0;
    nextNoteIndex = 0;
    score = 0;
    health = 50;
    if (isPracticeMode) health = 100;
    combo = 0;
    maxCombo = 0;
    multiplier = 1;
    stats = { perfect:0, great:0, good:0, miss:0 };
    lastFrameTime = performance.now();
    pressedKeys = {};
    
    document.getElementById('menu-overlay').style.display = 'none';
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('post-game').style.display = 'none';
    updateHUD();
    
    // START MUSIC
    startMusic(levelId);
    
    requestAnimationFrame(gameLoop);
}

function handleInput(e) {
    if (gameState !== 'PLAYING') return;
    if (e.key.length === 1) e.preventDefault();

    const pressedKey = e.key;
    
    let visualChar = pressedKey.toLowerCase();
    if(SHIFT_MAP[pressedKey]) visualChar = SHIFT_MAP[pressedKey];
    else if(pressedKey.match(/[A-Z]/)) visualChar = pressedKey.toLowerCase();
    
    pressedKeys[visualChar] = gameTime;

    const validNotes = notes.filter(n => !n.hit && !n.processed && n.char === pressedKey);
    
    if (validNotes.length === 0) {
        // GHOST TAP / WRONG KEY
        breakCombo();
        if (!isPracticeMode) health -= 2;
        playSound('error');
        return;
    }

    const targetNote = validNotes.reduce((prev, curr) => {
        return Math.abs(curr.targetTime - gameTime) < Math.abs(prev.targetTime - gameTime) ? curr : prev;
    });

    const diff = Math.abs(targetNote.targetTime - gameTime) * 1000; 

    if (diff <= HIT_WINDOW_GOOD) {
        targetNote.hit = true;
        targetNote.processed = true;
        
        let points = 0;
        let flavor = "";
        let color = "";
        
        if (diff <= HIT_WINDOW_PERFECT) {
            flavor = "PERFECT";
            points = 100;
            color = "#00ffff"; 
            stats.perfect++;
            health += 5;
        } else if (diff <= HIT_WINDOW_GREAT) {
            flavor = "GREAT";
            points = 75;
            color = "#00ff00"; 
            stats.great++;
            health += 3;
        } else {
            flavor = "GOOD";
            points = 50;
            color = "#ffff00"; 
            stats.good++;
            health += 1;
        }
        
        score += points * multiplier;
        incrementCombo();
        
        spawnExplosion(targetNote.x, targetNote.y, color);
        particles.push(new FloatingText(flavor, targetNote.x, targetNote.y - 60, color));
        playSound('type');
        
        if (health < 100) health += (isPracticeMode ? 0 : points/20);

    } else {
        // Ignored
    }
    
    updateHUD();
}

function updateSpeed(val) {
    timeScale = parseFloat(val);
    document.getElementById('speed-value').innerText = Math.round(timeScale * 100) + '%';
}

function breakCombo() {
    combo = 0;
    multiplier = 1;
    updateHUD();
    const comboEl = document.getElementById('combo-display');
    comboEl.style.opacity = 0;
}

function incrementCombo() {
    combo++;
    if (combo > maxCombo) maxCombo = combo;
    
    if (combo >= 30) multiplier = 4;
    else if (combo >= 20) multiplier = 3;
    else if (combo >= 10) multiplier = 2;
    else multiplier = 1;
    
    const comboEl = document.getElementById('combo-display');
    comboEl.textContent = `COMBO ${combo}!`;
    comboEl.style.opacity = 1;
    comboEl.style.transform = "translateX(-50%) scale(1.2)";
    setTimeout(() => {
        comboEl.style.transform = "translateX(-50%) scale(1.0)";
    }, 100);
}

function spawnExplosion(x, y, color) {
    for(let i=0; i<10; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function failGame() {
    gameState = 'GAMEOVER';
    stopMusic();
    showPostGame(false);
    playSound('miss');
}

function finishLevel() {
    gameState = 'GAMEOVER';
    stopMusic();
    showPostGame(true);
}

// --- RENDERING ---

function drawBackground(ctx) {
    const time = performance.now() * 0.001;
    
    // Create screensaver-like drift
    const hue1 = (time * 10) % 360;
    const hue2 = (time * 15 + 180) % 360;
    
    const gradient = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    gradient.addColorStop(0, `hsla(${hue1}, 60%, 10%, 1)`);
    gradient.addColorStop(1, `hsla(${hue2}, 60%, 5%, 1)`);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Abstract drifting grid lines
    ctx.strokeStyle = `hsla(${hue1}, 50%, 50%, 0.1)`;
    ctx.lineWidth = 2;
    
    const offset = (time * 50) % 200;
    
    for (let i = 0; i < CANVAS_WIDTH + 200; i += 200) {
        ctx.beginPath();
        // Slanted lines for motion
        ctx.moveTo(i - offset, 0);
        ctx.lineTo(i - offset - 100, CANVAS_HEIGHT);
        ctx.stroke();
    }
}

function drawKeyboard(ctx) {
    ctx.lineWidth = 2;
    ctx.font = '16px "Roboto Mono"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    for (const char in KEY_COORDS) {
        const k = KEY_COORDS[char];
        
        const isPressed = pressedKeys[char] && (gameTime - pressedKeys[char] < 0.15);
        
        if (isPressed) {
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffff';
            ctx.strokeStyle = '#fff';
            ctx.fillRect(k.x, k.y, k.w, k.h);
        } else {
            ctx.fillStyle = 'rgba(20, 20, 20, 0.8)'; 
            ctx.strokeStyle = '#555';
            ctx.shadowBlur = 0;
            ctx.fillRect(k.x, k.y, k.w, k.h);
        }
        
        ctx.beginPath();
        ctx.roundRect(k.x, k.y, k.w, k.h, 4);
        ctx.stroke();
        
        ctx.fillStyle = isPressed ? '#fff' : '#888';
        ctx.fillText(char.toUpperCase(), k.x + k.w/2, k.y + k.h/2);
    }
}

function gameLoop(timestamp) {
    if (gameState !== 'PLAYING') return;

    const realDt = (timestamp - lastFrameTime) / 1000;
    lastFrameTime = timestamp;
    const dt = realDt * timeScale;
    gameTime += dt;

    // --- LOGIC ---
    
    const maxDist = (CANVAS_HEIGHT - SPAWN_Y);
    const maxTravelTime = maxDist / currentScrollSpeed;
    
    while(nextNoteIndex < songChart.length) {
        const noteData = songChart[nextNoteIndex];
        if (gameTime >= noteData.time - maxTravelTime) {
            notes.push(new Note(noteData.char, noteData.time));
            nextNoteIndex++;
        } else {
            break;
        }
    }
    
    if (nextNoteIndex >= songChart.length && notes.length === 0) {
        finishLevel();
        return;
    }

    for (let i = notes.length - 1; i >= 0; i--) {
        const n = notes[i];
        
        const missLine = n.targetY + 40; 
        
        if (!n.processed && n.y > missLine) {
            n.processed = true;
            stats.miss++;
            if (!isPracticeMode) health -= 20;
            breakCombo();
            particles.push(new FloatingText("MISS", n.x, n.y, "#ff0000"));
            
            playSound('miss');
        }
        
        if (n.y > CANVAS_HEIGHT + 50) notes.splice(i, 1);
    }
    
    if (health > 100) health = 100;
    if (health <= 0 && !isPracticeMode) {
        failGame();
        return;
    }
    
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(dt);
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    // --- DRAW ---
    drawBackground(ctx);
    
    // Center Perspective
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    const centerX = CANVAS_WIDTH / 2;
    
    drawKeyboard(ctx);
    notes.forEach(n => n.draw(ctx));
    particles.forEach(p => p.draw(ctx));

    updateHUD();
    requestAnimationFrame(gameLoop);
}

// --- UI & MENUS ---

function updateHUD() {
    document.getElementById('score-display').innerText = score.toString().padStart(6, '0');
    document.getElementById('multiplier-display').innerText = 'x' + multiplier;
    
    const hb = document.getElementById('health-bar');
    if (isPracticeMode) {
        hb.style.width = '100%';
        hb.style.background = '#00ffff'; 
    } else {
        hb.style.width = health + '%';
        if (health < 30) hb.style.background = '#ff0000';
        else if (health < 60) hb.style.background = '#ffff00';
        else hb.style.background = '#00ff00';
    }

    // Progress Bar
    const progress = Math.min((gameTime / SONG_DURATION) * 100, 100);
    document.getElementById('progress-fill').style.width = progress + '%';
}

function initMenu() {
    initKeyboardCoords();
    
    const grid = document.getElementById('level-buttons');
    grid.innerHTML = '';
    
    LEVEL_DATA.forEach(level => {
        const btn = document.createElement('button');
        
        // Add completion styling
        if (completedLevels.has(level.id)) {
            btn.classList.add('completed');
        }
        
        btn.innerHTML = `<div>Lvl ${level.id}</div><div style="font-size:0.8em; color: #888">${level.name}</div>`;
        btn.onclick = () => initGame(level.id);
        grid.appendChild(btn);
    });
}

function showPostGame(cleared) {
    document.getElementById('menu-overlay').style.display = 'flex';
    document.getElementById('main-menu').style.display = 'none';
    const p = document.getElementById('post-game');
    p.style.display = 'block';
    
    if (!cleared) {
        document.getElementById('report-title').innerText = "SYSTEM FAILURE";
        document.getElementById('report-title').style.color = "red";
        document.getElementById('report-grade').innerText = "F";
        document.getElementById('report-grade').style.color = "red";
    } else {
        document.getElementById('report-title').innerText = "MISSION COMPLETE";
        document.getElementById('report-title').style.color = "#00ffff";
        
        const total = stats.perfect + stats.great + stats.good + stats.miss;
        const hits = stats.perfect + stats.great + stats.good;
        const accuracy = total > 0 ? (hits / total) * 100 : 0;
        
        let grade = "C";
        if (accuracy >= 98) grade = "S";
        else if (accuracy >= 90) grade = "A";
        else if (accuracy >= 80) grade = "B";
        
        document.getElementById('report-grade').innerText = grade;
        document.getElementById('report-grade').style.color = "gold";
        document.getElementById('report-accuracy').innerText = accuracy.toFixed(1) + "%";
        
        // Mark Level as Completed
        completedLevels.add(currentLevelData.id);
    }
    
    document.getElementById('report-score').innerText = score;
    document.getElementById('report-combo').innerText = maxCombo;
    document.getElementById('report-perfect').innerText = stats.perfect;
    document.getElementById('report-great').innerText = stats.great;
    document.getElementById('report-good').innerText = stats.good;
    document.getElementById('report-miss').innerText = stats.miss;
}

function returnToMenu() {
    document.getElementById('post-game').style.display = 'none';
    document.getElementById('main-menu').style.display = 'block';
    initMenu(); // Re-render menu to show completed levels
}

// --- BOOTSTRAP ---
window.addEventListener('keydown', handleInput);
window.onload = initMenu;

</script>
</body>
</html>
